console.log('hello while, for')
//  цикл < while >
//
//  while (condition) {
//       код
//       также называемый "телом цикла"
//  }
//
//  Код из тела цикла выполняется, пока условие condition истинно.
//  Одно выполнение тела цикла по-научному называется итерация.
//  Любое выражение или переменная может быть условием цикла, а не только сравнение:
//  условие while вычисляется и преобразуется в логическое значение.
//  Например, while (i) – более краткий вариант while (i != 0):
//
//  let i = 3;
//  while (i) {
//      alert(i)
//      i--;
//  }
//
//  Фигурные скобки не требуются для тела цикла из одной строки
//  let i = 3;
//  while (i) alert(i--);


//  Цикл «do…while»
//
//  Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:
//
//  do {
//    тело цикла
//  } while (condition);
//
//  Цикл сначала выполнит тело, а затем проверит условие condition,
//  и пока его значение равно true, он будет выполняться снова и снова.
//
//  let i = 0;
//  do {
//    alert( i );
//    i++;
//  } while (i <= 3);


//  Цикл «for»
//
//  Более сложный, но при этом самый распространённый цикл — цикл for.
//
//  for (начало; условие; шаг) {
//     тело цикла 
//  }
//
//  for (let i = 0; i < 3; i++) {  
//     выведет 0, затем 1, затем 2
//     alert(i);
//  }
//
//  начало	let i = 0	Выполняется один раз при входе в цикл
//  условие	i < 3	Проверяется перед каждой итерацией цикла.
//  Если оно вычислится в false, цикл остановится.
//  тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
//  шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
//
//  В целом, алгоритм работы цикла выглядит следующим образом:
//  Выполнить начало
//  → (Если условие == true → Выполнить тело, Выполнить шаг)
//  → (Если условие == true → Выполнить тело, Выполнить шаг)
//  → (Если условие == true → Выполнить тело, Выполнить шаг)
//  → ...
//
//  То есть, начало выполняется один раз, 
//  а затем каждая итерация заключается в проверке условия,
//  после которой выполняется тело и шаг.
//
//  В примере переменная счётчика i была объявлена прямо в цикле. 
//  Это так называемое «встроенное» объявление переменной. 
//  Такие переменные существуют только внутри цикла.
//
//  for (let i = 0; i < 3; i++) {
//     alert(i); // 0, 1, 2
//  }
//  alert(i); // ошибка, нет такой переменной
//
//  Вместо объявления новой переменной мы можем использовать уже существующую:
//
//  let i = 0;
//  for (i = 0; i < 3; i++) { //
//     используем существующую переменную
//     alert(i); // 0, 1, 2
//  }
//  alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла


//  Пропуск частей «for»
//
//  Любая часть for может быть пропущена.
//  Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.
//  Вот так:
//
//  let i = 0; // мы уже имеем объявленную i с присвоенным значением
//  for (; i < 3; i++) { // нет необходимости в "начале"
//     alert( i ); // 0, 1, 2
//  }
//
//  Можно убрать и шаг:
//
//  let i = 0;
//  for (; i < 3;) {
//     alert( i++ );
//  }
//
//  А можно и вообще убрать всё, получив бесконечный цикл:
//
//  for (;;) {
//     будет выполняться вечно
//  }  
//
//  При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.


//  Прерывание цикла: «break»
//
//  Обычно цикл завершается при вычислении условия в false.
//  Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.
//  Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит,
//  а затем – выдаёт:
//
//  let sum = 0;
//  while (true) {
//       let value = +prompt("Введите число", '');
//       if (!value) break; // (*)
//       sum += value;
//  }
//  alert( 'Сумма: ' + sum );
//
//  Директива break в строке (*) полностью прекращает выполнение цикла 
//  и передаёт управление на строку за его телом, то есть на alert.
//  Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, 
//  когда условие, по которому нужно прерваться, находится не в начале или конце цикла,
//  а посередине или даже в нескольких местах его тела.


//  Переход к следующей итерации: continue
//
//  Директива continue – «облегчённая версия» break. 
//  При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).
//  Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
//  Например, цикл ниже использует continue, чтобы выводить только нечётные значения:
//
//  for (let i = 0; i < 10; i++) {
//      если true, пропустить оставшуюся часть тела цикла
//      if (i % 2 == 0) continue;
//      alert(i); // 1, затем 3, 5, 7, 9
//  }
//
//  Для чётных значений i, директива continue прекращает выполнение тела цикла 
//  и передаёт управление на следующую итерацию for (со следующим числом).
//  Таким образом alert вызывается только для нечётных значений.


//  Нельзя использовать break/continue справа от оператора „?“
//
//  if (i > 5) {
//    alert(i);
//  } else {
//        continue;
//  }
//
//  …и перепишем его, используя вопросительный знак:
//
//  (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке.


//  Метки для break/continue
//
//  Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.
//  Нам нужен способ остановить выполнение, если пользователь отменит ввод.
//  Обычный break после input лишь прервёт внутренний цикл, но этого недостаточно. 
//  Достичь желаемого поведения можно с помощью меток.
//
//  Метка имеет вид идентификатора с двоеточием перед циклом:
//
//  labelName: for (...) {
//                ...
//             }
//
//  Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
//
//  outer: for (let i = 0; i < 3; i++) {
//            for (let j = 0; j < 3; j++) {
//               let input = prompt(`Значение на координатах (${i},${j})`, '');
//               если пустая строка или Отмена, то выйти из обоих циклов
//               if (!input) break outer; // (*)
//               сделать что-нибудь со значениями...
//            }
//         }
//  alert('Готово!');
//
//  В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки с именем outer.
//  Таким образом управление перейдёт со строки, помеченной (*), к alert('Готово!').
//  Можно размещать метку на отдельной строке:
//
//  outer:
//  for (let i = 0; i < 3; i++) { ... }
//
//  Директива continue также может быть использована с меткой. 
//  В этом случае управление перейдёт на следующую итерацию цикла с меткой.
//  Метки не дают возможности передавать управление в произвольное место кода.
//
//  Например, нет возможности сделать следующее:
//
//  break label; // не прыгает к метке ниже
//  label: for (...)
//
//  Директива break должна находиться внутри блока кода.
//  Технически, подойдет любой маркированный блок кода, например:
//
//  label: {
//        ...
//        break label; // работает
//        ...
//  }
//
//  break используется внутри циклов,
//  continue возможно только внутри цикла.
//
//  Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
//
//  Обе этих директивы поддерживают метки, которые ставятся перед циклом. 
//  Метки – единственный способ для break/continue выйти за пределы текущего цикла,
//  повлиять на выполнение внешнего.